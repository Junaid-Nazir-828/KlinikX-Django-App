(function (e, t) {
  if (typeof exports === "object" && typeof module === "object") {
    module.exports = t();
  } else if (typeof define === "function" && define.amd) {
    define([], t);
  } else if (typeof exports === "object") {
    exports.counterUp = t();
  } else {
    e.counterUp = t();
  }
})(self, function () {
  return (() => {
    "use strict";
    var e = {
      d: (t, n) => {
        for (var o in n) {
          if (e.o(n, o) && !e.o(t, o)) {
            Object.defineProperty(t, o, {
              enumerable: true,
              get: n[o],
            });
          }
        }
      },
      o: (e, t) => Object.prototype.hasOwnProperty.call(e, t),
      r: (e) => {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module",
          });
        }
        Object.defineProperty(e, "__esModule", { value: true });
      },
    };
    var t = {};
    e.r(t);
    e.d(t, { default: () => n, divideNumbers: () => r });
    const n = (e, t = {}) => {
      const { action: n = "start", duration: i = 1000, delay: u = 16 } = t;
      if (n === "stop") {
        return void o(e);
      }
      if (!/[0-9]/.test(e.innerHTML)) {
        return;
      }
      const l = r(e.innerHTML, {
        duration: i || e.getAttribute("data-duration"),
        delay: u || e.getAttribute("data-delay"),
      });
      e._countUpOrigInnerHTML = e.innerHTML;
      e.innerHTML = l[0] || "&nbsp;";
      e.style.visibility = "visible";
      const c = () => {
        e.innerHTML = l.shift() || "&nbsp;";
        if (l.length) {
          clearTimeout(e.countUpTimeout);
          e.countUpTimeout = setTimeout(c, u);
        } else {
          e._countUpOrigInnerHTML = void 0;
        }
      };
      e.countUpTimeout = setTimeout(c, u);
    };
    const o = (e) => {
      clearTimeout(e.countUpTimeout);
      if (e._countUpOrigInnerHTML) {
        e.innerHTML = e._countUpOrigInnerHTML;
        e._countUpOrigInnerHTML = void 0;
      }
      e.style.visibility = "";
    };
    const r = (e, t = {}) => {
      const { duration: n = 1000, delay: o = 16 } = t;
      const r = n / o;
      const i = e.toString().split(/(<[^>]+>|[0-9.][,.0-9]*[0-9]*)/);
      const u = [];
      for (let e = 0; e < r; e++) {
        u.push("");
      }
      for (let e = 0; e < i.length; e++) {
        if (/([0-9.][,.0-9]*[0-9]*)/.test(i[e]) && !/<[^>]+>/.test(i[e])) {
          let t = i[e];
          const n = [...t.matchAll(/[.,]/g)]
            .map((e) => ({ char: e[0], i: t.length - e.index - 1 }))
            .sort((e, t) => e.i - t.i);
          t = t.replace(/[.,]/g, "");
          let o = u.length - 1;
          for (let e = r; e >= 1; e--) {
            let i = parseInt((t / r) * e, 10);
            i = n.reduce(
              (e, { char: t, i: n }) =>
                e.length <= n ? e : e.slice(0, -n) + t + e.slice(-n),
              i.toString()
            );
            u[o--] += i;
          }
        } else {
          for (let t = 0; t < r; t++) {
            u[t] += i[e];
          }
        }
      }
      u[u.length] = e.toString();
      return u;
    };
    return t;
  })();
});

// Counter for header.html
const counterUp = window.counterUp.default;

const callback = (entries) =>
  entries.forEach((entry) => {
    const el = entry.target;
    if (entry.isIntersecting && !el.classList.contains("is-visible")) {
      counterUp(el, { duration: 2000, delay: 16 });
      el.classList.add("is-visible");
    }
  });

const IO = new IntersectionObserver(callback, { threshold: 1 });

document.querySelectorAll(".counter").forEach((el) => IO.observe(el));
